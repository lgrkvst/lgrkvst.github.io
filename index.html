<!DOCTYPE html>
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="msapplication-tap-highlight" content="no">
<meta name="description" content="Continuous Delivery Home">
<title>Curriculum Vitae &mdash; Christian Lagerkvist</title>
<link rel="stylesheet" href="materialize/css/materialize.css">
<link rel="stylesheet" href="css/greenfield.css">
<link rel="stylesheet" href="css/chart.css">
</head>

<body>
<section class="main">
<div class="container">
<div class="row">
<div class="col s7 heroheader">
<h2>
			<div class="outdent">curriculum vitae</div>
			VISUALISED
		</h2>
<!-- <h5 class="byline">Christian Lagerkvist</h5>
 --></div>
</div>
</div>
<div class="row">
<!-- Switch -->
<!-- <div class="switch right">
<label>
time
<input type="checkbox" onchange="javascript:toggle();">
<span class="lever light-green lighten-4"></span> geo
</label>
</div>
 -->
<svg width="900" height="520">
<defs>
<filter id="dropshadow" height="200%">
<feGaussianBlur in="SourceAlpha" stdDeviation="2" />
<!-- stdDeviation is how much to blur -->
<feOffset dx="0" dy="0" result="offsetblur" />
<!-- how much to offset -->
<feMerge>
<feMergeNode/>
<!-- this contains the offset blurred image -->
<feMergeNode in="SourceGraphic" />
<!-- this contains the element that the filter is applied to -->
</feMerge>
</filter>
<linearGradient id="yearline" x1="50%" y1="100%" x2="50%" y2="0%">
<stop offset="0%" style="stop-color:#000;stop-opacity:0" />
<stop offset="50%" style="stop-color:#000;stop-opacity:0.2" />
<stop offset="100%" style="stop-color:#000;stop-opacity:0" />
</linearGradient>
</defs>
</svg>
</div>
</section>
</body>
<script src="js/lib/d3.min.js"></script>
<script src="js/lib/d3-scale-chromatic.v1.min.js"></script>
<script src="js/lib/least-squares.js"></script>
<script src="js/lib/textwrap.js"></script>
<script src="js/lib/d3-bboxCollide.min.js"></script>
<script>
var svg = d3.select("svg");
svg.attr("width", d3.select("body").node().getBoundingClientRect().width);

var margin = {
        top: 120,
        right: 0,
        bottom: 170,
        left: 0
    },
    margin2 = {
        top: 470,
        right: 0,
        bottom: 20,
        left: 0
    },
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom,
    height2 = +svg.attr("height") - margin2.top - margin2.bottom;

var x = d3.scaleTime().range([0, width]),
    x2 = d3.scaleTime().range([0, width]),
    x2_to_x = d3.scaleLinear().range([0, width]),
    y = d3.scaleLinear().range([height, 0]),
    y2 = d3.scaleLinear().range([height2, 0]);

var startRange = [81, width];

var xAxis = d3.axisBottom(x),
    xAxis2 = d3.axisBottom(x2),
    yAxis = d3.axisRight(y).ticks(4).tickFormat(y_formatter);

function y_formatter(tick) {
    var ret = "";
    if (tick == 0) return ret;
    ret = d3.format(".0%")(Math.abs(tick));
    if (tick == 1) ret += " arbete";
    if (tick == -1) ret += " studier/fritid";
    return ret;
}

svg.append("defs").append("clipPath")
    .attr("id", "clip")
    .append("rect")
    .attr("width", width)
    .attr("height", height);

var focus = svg.append("g")
    .attr("class", "focus")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var context = svg.append("g")
    .attr("class", "context")
    .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");


d3.queue()
    .defer(d3.json, "data/cv_stack.json")
    .defer(d3.json, "data/cv_descriptions.json")
    .await(drawTimeline);


function drawTimeline(error, stack, descriptions) {
    if (error) throw new Error("no data");
    var yyyy = d3.timeParse("%Y");
    var labels = [],
        _labels = {};

    var is_work = function() {
        var study_or_work = {};
        descriptions.forEach(o => {
            study_or_work[o.name] = o.type;
        });

        return function(item) {
            return study_or_work[item] == "work";
        }
    }();

    stack.forEach(year => {
        year["date"] = yyyy(year["date"]);

        // determine label x positions
        for (job in year) {
            if (job != "date") {
                if (!_labels[job]) {
                    _labels[job] = {};
                    _labels[job]["product"] = 0;
                    _labels[job]["weight"] = 0;
                    _labels[job]["top"] = 0;
                    _labels[job]["topyear"] = 0;
                }
                _labels[job]["product"] += year.date.getTime() * year[job];
                _labels[job]["weight"] += year[job];
                if (_labels[job]["top"] < year[job]) {
                    _labels[job]["top"] = year[job];
                }
            }
        }

        descriptions.forEach(description => {
            if (!year[description.name]) year[description.name] = 0.01;
        });

    });

    var dByName = d3.nest().key(o => o.name).rollup(o => o[0]).object(descriptions);

    for (_label in _labels) {
        let d,
            x = new Date(_labels[_label]["product"] / _labels[_label]["weight"]),
            y = _labels[_label]["top"];

        if (d = dByName[_label].label) {
            if (d.x) x = new Date(d.x);
            if (d.y) y = d.y;
        }

        labels.push({
            "x": x,
            "y": y,
            "name": _label
        });
    }

    var brush = d3.brushX()
        .extent([
            [0, 0],
            [width, height2]
        ])
        .on("brush end", brushed);

    var zoom = d3.zoom()
        .scaleExtent([1, Infinity])
        .translateExtent([
            [0, 0],
            [width, height]
        ])
        .extent([
            [0, 0],
            [width, height]
        ])
        .on("zoom", zoomed);

    function axis_callback() {
        // render x-axis as bar:
        var width = svg.attr("width");
        d3.select(".axis--x").select("path.domain").attr("d", "M0,0L0,28L" + (width) + ",28L+" + (width + 10) + ",14L" + width + ",0Z");

        // draw yearlines
        var yearlines = focus.selectAll("rect.yearline").data(x2.ticks(d3.timeYear, 1));
        var yearwidth = x(x.ticks(d3.timeYear, 1)[1]) - x(x.ticks(d3.timeYear, 1)[0]);
        yearlines.exit().remove();
        yearlines = yearlines.enter()
            .insert("rect", ":first-child")
            .attr("class", "yearline")
            .merge(yearlines);
        yearlines
            .style("fill", "url(#yearline)")
            .style("opacity", (o, i) => o.getYear() % 2 ? 1 : 0.8)
            .attr("x", o => x(o) - yearwidth)
            .attr("y", 0)
            .attr("width", yearwidth + 1)
            .attr("height", (o, i) => height - i * 5);
    }

    // Linedrawer – Timeline sets x() itself

    var workarea = d3.area()
        .curve(d3.curveCatmullRom)
        .x(function(d) {

            return x(d.data.date);
        })
        .y0(function(d) {
            return y(d[0]);
        })
        .y1(function(d) {
            return y(d[1]);
        });

    var studyarea = d3.area()
        .curve(d3.curveCatmullRom)
        .x(function(d) {
            return x(d.data.date);
        })
        .y0(function(d) {
            return y(-d[1]);
        })
        .y1(function(d) {
            return y(-d[0]);
        });

    x.domain([stack[0].date, stack[stack.length - 1].date]);
    y.domain([-1.1, 1.1]);
    x2_to_x.domain(x2.range());
    x2.domain(x.domain());
    y2.domain(y.domain());

    var workkeys = descriptions.filter(o => o.type == "work").map(o => o.name);
    var studykeys = descriptions.filter(o => o.type == "study").map(o => o.name);

    var workdata = d3.stack().keys(workkeys).order(d3.stackOrderNone)(stack);

    var studydata = d3.stack().keys(studykeys).order(d3.stackOrderNone)(stack);

    var workcolor = d3.scaleSequential(d3.interpolateOranges).domain([0, 10]);
    var studycolor = d3.scaleSequential(d3.interpolateBlues).domain([5, -5]);


    focus.append("g")
        .attr("transform", "translate(0,-10)")
        .selectAll("path")
        .data(workdata)
        .enter()
        .each(function(o, i) {
            d3.select(this)
                .append("path")
                .attr("class", "stream workarea")
                .attr("fill", "url(#work_gradient_" + i + ")");
            d3.select(this)
                .append("defs")
                .append("linearGradient")
                .attr("id", "work_gradient_" + o.index)
                .attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", 1)
                .each(function(oo) {
                    d3.select(this).append("stop").attr("offset", "0%").attr("stop-color", workcolor(i));
                    d3.select(this).append("stop").attr("offset", "100%").attr("stop-color", workcolor(i - 2)).attr("stop-opacity", "0.5");
                })
        })

    focus.append("g")
        .attr("transform", "translate(0,10)")
        .selectAll("path")
        .data(studydata)
        .enter()
        .each(function(o, i) {
            d3.select(this)
                .append("path")
                .attr("class", "stream studyarea")
                .attr("fill", "url(#study_gradient_" + i + ")");
            d3.select(this)
                .append("defs")
                .append("linearGradient")
                .attr("id", "study_gradient_" + o.index)
                .attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", 1)
                .each(function(oo) {
                    d3.select(this).append("stop").attr("offset", "0%").attr("stop-color", studycolor(i - 2)).attr("stop-opacity", "0.5");
                    d3.select(this).append("stop").attr("offset", "100%").attr("stop-color", studycolor(i));
                })
        })

    // focus.selectAll(".stream")
    //     .on("mouseover", function(d, i) {
    //     	d3.select(this).style("fill", "white");

    //     })
    //     .on("mouseout", function(d, i) {
    //         svg.selectAll(".layer")
    //             .transition()
    //             .duration(250)
    //             .attr("opacity", "1");
    //         d3.select(this)
    //             .classed("hover", false)
    //             .attr("stroke-width", "0px"), indicator.style("visibility", "hidden");
    //     })


    //                                                ,,
    //                                                db

    //                                      ,pP"Ybd `7MM  `7MMpMMMb.pMMMb.
    //                                      8I   `"   MM    MM    MM    MM
    //                                      `YMMMa.   MM    MM    MM    MM
    //                                      L.   I8   MM    MM    MM    MM
    //                                      M9mmmP' .JMML..JMML  JMML  JMML.


    // todo: Det känns som att nätverket är labilt. Undersök varför allt barkar åt vänster om man tar bort event.fx-tilldelningen.
    var events = [];
    descriptions.forEach(o => {
        if (o.events) o.events.forEach(event => {
            event.date = event.fx = x2(new Date(event.date));
            event.type = o.type;
            events.push(event);
        });
    });

    var nodes = d3.merge([events, d3.range(events.length).map((o, i) => {
        return {
            "type": events[i].type
        }
    })]);

    var links = [];
    for (let i = 0; i < nodes.length / 2; i++) {
        links.push({
            source: i,
            target: i + nodes.length / 2
        })
    }


    var simulation = d3.forceSimulation(nodes)
    	.force("force", d3.forceManyBody().strength(-50))
        .force("collide", d3.forceCollide()/*d3.bboxCollide([
            [0, 0],
            [70, 30]
        ])*/)
        .force("y", d3.forceY(o => o.type == "study" ? y(-1.2) : y(1.5)).strength(0.07))
        // .force("x", d3.forceX(o => {return o.date ? x(o.date) : null}))
        .force("links", d3.forceLink(links).strength(0.82))
        .on("tick", tick);

    simulation.nodes().forEach(o => {
    	o.y = y(0);
    })

    var wrap = d3.textwrap().bounds({
        height: 100,
        width: 130
    }) /*.method('tspans')*/ ;

    var g_events = focus.selectAll("g.events").data(links);
    g_events = g_events.enter().append("g").attr("class", "event").each(function(o) {
        d3.select(this).append("path");
        d3.select(this).append("text")
            .text(o.source.description).call(wrap);
        d3.select(this).append("circle").attr("class", "lineend").attr("r", 2).style("fill", "#444");

        if (false) {
            d3.select(this).insert("circle", ":first-child").attr("class", "source").attr("r", 6).style("fill", "#efefef").style("stroke", "#aaa");
            d3.select(this).insert("circle", ":first-child").attr("class", "target").attr("r", 3).style("fill", "red");
        }
    });


    function tick() {
        g_events.selectAll("path").attr("d", o => {
            return "M" + x2_to_x(o.source.x) + "," + (o.source.y - 5) + "L" + x2_to_x(o.source.date) + "," + (y(0) - 14);
        });
        g_events.selectAll(wrap.method() == "foreignobject" ? "foreignObject" : "text")
            .attr("x", o => {
                if (o.source.x > o.target.x && wrap.method() == "foreignobject") return x2_to_x(o.source.x) - 130;
                return x2_to_x(o.source.x);
            })
            .attr("y", o => (o.source.y) - 10)
            .attr("text-anchor", (o) => {
                return (o.source.x < o.target.x) ? "start" : "end";
            })
            .style("text-align", (o) => {
                return (o.source.x < o.target.x) ? "left" : "right";
            })
            .select("tspan").attr("dx", o => {
                return (o.source.x < o.target.x) ? "5" : "-5";
            })
        g_events.selectAll("circle.source").attr("cx", o => x2_to_x(o.source.x)).attr("cy", o => o.source.y);
        g_events.selectAll("circle.target").attr("cx", o => x2_to_x(o.target.x)).attr("cy", o => o.target.y);
        g_events.selectAll("circle.lineend").attr("cx", o => x2_to_x(o.source.x)).attr("cy", o => o.source.y - 5).style("fill");
    }



    //   ,,           ,,                  ,,
    // `7MM          *MM                `7MM
    //   MM           MM                  MM
    //   MM   ,6"Yb.  MM,dMMb.   .gP"Ya   MM  ,pP"Ybd
    //   MM  8)   MM  MM    `Mb ,M'   Yb  MM  8I   `"
    //   MM   ,pm9MM  MM     M8 8M""""""  MM  `YMMMa.
    //   MM  8M   MM  MM.   ,M9 YM.    ,  MM  L.   I8
    // .JMML.`Moo9^Yo.P^YbmdP'   `Mbmmd'.JMML.M9mmmP'


    focus.selectAll("g.label")
        .data(labels)
        .enter()
        .append("g")
        .attr("class", o => {
            return "label " + (is_work(o.name) ? "worklabel" : "studylabel");
        })
        // .append("circle")
        // .attr("r", 4)
        // .attr("y", o => {
        //     //debugger;
        // });
        .append("text")
        .attr("y", o => {
            var sign = is_work(o.name) ? 1 : -1;
            return y(sign * Math.sqrt(o.y) / 1.1) + 5;
        })
        .text(o => o.name)
        .each(rectify);

    function rectify(d, i) {
        var labelmargin = 4;
        var parent = d3.select(this.parentNode);
        var box = this.getBBox();
        box.x += d3.select(this).attr("x");

        parent.insert("rect", ":first-child")
            .attr("x", box.x - labelmargin)
            .attr("y", box.y)
            .attr("rx", 3)
            .attr("ry", 3)
            .attr("width", box.width + 2 * labelmargin)
            .attr("height", box.height)
    }



    //                       ,,
    //                       db

    //  ,6"Yb.  `7M'   `MF'`7MM  ,pP"Ybd
    // 8)   MM    `VA ,V'    MM  8I   `"
    //  ,pm9MM      XMX      MM  `YMMMa.
    // 8M   MM    ,V' VA.    MM  L.   I8
    // `Moo9^Yo..AM.   .MA..JMML.M9mmmP'



    focus.append("g")
        .attr("class", "axis axis--x focus")
        .attr("transform", "translate(0," + (y(0) - 14) + ")")
        .style("filter", "url(#dropshadow)")
        .call(xAxis);

    focus.append("g")
        .attr("class", "axis axis--y")
        .call(yAxis);

    context.append("g")
        .attr("class", "axis axis--x context")
        .attr("transform", "translate(0," + height2 + ")")
        .call(xAxis2);

    context.append("g")
        .attr("class", "brush")
        .call(brush)
        .call(brush.move, startRange);

    svg.append("rect")
        .attr("class", "zoom")
        .attr("width", width)
        .attr("height", height)
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        .call(zoom);



    function brushed() {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
        var s = d3.event.selection || x2.range();
        x.domain(s.map(x2.invert, x2));
        x2_to_x.domain(s);

        focus.select(".axis--x").call(xAxis);
        svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
            .scale(width / (s[1] - s[0]))
            .translate(-s[0], 0));

        focus.selectAll(".workarea").attr("d", workarea);
        focus.selectAll(".studyarea").attr("d", studyarea);
        focus.selectAll(".label").attr("transform", o => "translate(" + x(o.x) + ")");

        // fix x-axis into bar:
        axis_callback();
        tick();
    }

    function zoomed() {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
        var t = d3.event.transform;
        x.domain(t.rescaleX(x2).domain());
        x2_to_x.domain(x.range().map(t.invertX, t));

        focus.select(".axis--x").call(xAxis);
        context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
        focus.selectAll(".workarea").attr("d", workarea);
        focus.selectAll(".studyarea").attr("d", studyarea);
        focus.selectAll(".label").attr("transform", o => "translate(" + x(o.x) + ")");

        // fix x-axis into bar:
        axis_callback();
        tick();
    }

}
</script>
