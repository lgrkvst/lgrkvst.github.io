<!DOCTYPE html>
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="msapplication-tap-highlight" content="no">
<meta name="description" content="Continuous Delivery Home">
<title>Curriculum Vitae &mdash; Christian Lagerkvist</title>
<link rel="stylesheet" href="materialize/css/materialize.css">
<link rel="stylesheet" href="css/greenfield.css">
<link rel="stylesheet" href="css/chart.css">
</head>

<body>
<section class="main">
<div class="container">
<div class="row">
<div class="col s7 heroheader">
<h2>
			<div class="outdent">curriculum vitae</div>
			VISUALISED
		</h2>
<h5 class="byline">Christian Lagerkvist</h5>
</div>
</div>
<div class="row">
<!-- Switch -->
<!-- <div class="switch right">
<label>
time
<input type="checkbox" onchange="javascript:toggle();">
<span class="lever light-green lighten-4"></span> geo
</label>
</div>
 -->
<svg width="900" height="400">
<defs>
<filter id="dropshadow" height="200%">
<feGaussianBlur in="SourceAlpha" stdDeviation="2" />
<!-- stdDeviation is how much to blur -->
<feOffset dx="0" dy="0" result="offsetblur" />
<!-- how much to offset -->
<feMerge>
<feMergeNode/>
<!-- this contains the offset blurred image -->
<feMergeNode in="SourceGraphic" />
<!-- this contains the element that the filter is applied to -->
</feMerge>
</filter>
<linearGradient id="yearline" x1="50%" y1="100%" x2="50%" y2="0%">
<stop offset="0%" style="stop-color:#000;stop-opacity:0" />
<stop offset="50%" style="stop-color:#000;stop-opacity:0.2" />
<stop offset="100%" style="stop-color:#000;stop-opacity:0" />
</linearGradient>
</defs>
</svg>
</div>
</div>
</section>
</body>
<script src="js/lib/d3.min.js"></script>
<script src="js/lib/d3-scale-chromatic.v1.min.js"></script>
<script src="js/lib/least-squares.js"></script>
<script>
var svg = d3.select("svg"),
    margin = {
        top: 20,
        right: 30,
        bottom: 110,
        left: 0
    },
    margin2 = {
        top: 330,
        right: 30,
        bottom: 30,
        left: 0
    },
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom,
    height2 = +svg.attr("height") - margin2.top - margin2.bottom;

var x = d3.scaleTime().range([0, width]),
    x2 = d3.scaleTime().range([0, width]),
    y = d3.scaleLinear().range([height, 0]),
    y2 = d3.scaleLinear().range([height2, 0]);

var startRange = [81, width];

var xAxis = d3.axisBottom(x),
    xAxis2 = d3.axisBottom(x2),
    yAxis = d3.axisRight(y).ticks(4).tickFormat(y_formatter);

function y_formatter(tick) {
    var ret = "";
    if (tick == 0) return ret;
    ret = d3.format(".0%")(Math.abs(tick));
    if (tick == 1) ret += " work";
    if (tick == -1) ret += " study";
    return ret;
}

svg.append("defs").append("clipPath")
    .attr("id", "clip")
    .append("rect")
    .attr("width", width)
    .attr("height", height);

var focus = svg.append("g")
    .attr("class", "focus")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var context = svg.append("g")
    .attr("class", "context")
    .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");


d3.queue()
    .defer(d3.json, "data/cv_stack.json")
    .defer(d3.json, "data/cv_descriptions.json")
    .await(drawTimeline);


function drawTimeline(error, stack, descriptions) {
    if (error) throw new Error("no data");
    var yyyy = d3.timeParse("%Y");
    var labels = [], _labels = {};

    stack.forEach(year => {
        year["date"] = yyyy(year["date"]);

        // determine label x positions
    	for (job in year) {
    		if (job != "date") {
    			if (!_labels[job]) {
    				_labels[job] = {};
    				_labels[job]["product"] = 0;
    				_labels[job]["weight"] = 0;
    				_labels[job]["top"] = 0;
    				_labels[job]["topyear"] = 0;
    			}
    			if (job == "Värnplikt") console.log(job);
	    		_labels[job]["product"] += year.date.getTime()*year[job];
	    		_labels[job]["weight"] += year[job];
	    		if (_labels[job]["top"] < year[job]) {
	    			_labels[job]["top"] = year[job];
	    		}
    		}
    	}

        descriptions.forEach(description => {
            if (!year[description.name]) year[description.name] = 0.01;
        });

    });

    for (_label in _labels) {
    	labels.push({"date": new Date(_labels[_label]["product"]/_labels[_label]["weight"]), "name": _label, "y": _labels[_label]["top"]});
    }

    console.log(labels)

    var studystack = JSON.parse(JSON.stringify(stack)),
        workstack = JSON.parse(JSON.stringify(stack));

    var study_or_work = {};
    descriptions.forEach(o => {
        study_or_work[o.name] = o.type;
    });

    function is_work(item) {
        return study_or_work[item] == "work";
    }

    studystack.forEach(year => {
        year["date"] = new Date(year["date"]);
        for (item in year) {
            if (item != "date" && is_work(item)) {
                delete(year[item]);
            }
        }
    });

    workstack.forEach(year => {
        year["date"] = new Date(year["date"]);
        for (item in year) {
            if (item != "date" && !is_work(item)) {
                delete(year[item]);
            }
        }
    });

    var brush = d3.brushX()
        .extent([
            [0, 0],
            [width, height2]
        ])
        .on("brush end", brushed);

    var zoom = d3.zoom()
        .scaleExtent([1, Infinity])
        .translateExtent([
            [0, 0],
            [width, height]
        ])
        .extent([
            [0, 0],
            [width, height]
        ])
        .on("zoom", zoomed);

    function axis_callback() {
        // render x-axis as bar:
        d3.select(".axis--x").select("path.domain").attr("d", "M0,0L0,28L870,28L880,14L870,0Z");

        // draw yearlines
        var yearlines = focus.selectAll("rect.yearline").data(x.ticks(d3.timeYear, 1));
        var yearwidth = x(x.ticks(d3.timeYear, 1)[1]) - x(x.ticks(d3.timeYear, 1)[0]);
        yearlines.exit().remove();
        yearlines = yearlines.enter()
            .insert("rect", ":first-child")
            .attr("class", "yearline")
            .merge(yearlines);
        yearlines
            .style("fill", "url(#yearline)")
            .style("opacity", (o, i) => o.getYear() % 2 ? 1 : 0.8)
            .attr("x", o => x(o) - yearwidth)
            .attr("y", 0)
            .attr("width", yearwidth + 1)
            .attr("height", (o, i) => height - i * 5);
    }

    // Linedrawer – Timeline sets x() itself

    var workarea = d3.area()
        .curve(d3.curveCatmullRom)
        .x(function(d) {

            return x(d.data.date);
        })
        .y0(function(d) {
            return y(d[0]);
        })
        .y1(function(d) {
            return y(d[1]);
        });

    var studyarea = d3.area()
        .curve(d3.curveCatmullRom)
        .x(function(d) {
            return x(d.data.date);
        })
        .y0(function(d) {
            return y(-d[1]);
        })
        .y1(function(d) {
            return y(-d[0]);
        });

    var linkLine = d3.line()
        .x(e => (e.x))
        .y(e => (e.y))
        .curve(d3.curveBasis);



    x.domain([stack[0].date, stack[stack.length - 1].date]);
    y.domain([-1.1, 1.1]);
    x2.domain(x.domain());
    y2.domain(y.domain());



    //                                                ,,
    //                                                db

    //                                      ,pP"Ybd `7MM  `7MMpMMMb.pMMMb.
    //                                      8I   `"   MM    MM    MM    MM
    //                                      `YMMMa.   MM    MM    MM    MM
    //                                      L.   I8   MM    MM    MM    MM
    //                                      M9mmmP' .JMML..JMML  JMML  JMML.

    /*
        var beadLinks = [];
        data.filter(d => d.values.length > 2).forEach(process => {
            for (var i = 0; i < process.values.length - 1; i++) {
                beadLinks.push({
                    source: process.values[i],
                    target: process.values[i + 1],
                    interbead: true
                });
            }
        });

        // shadow eventlog for label nodes
        var labelNodes = [];
        eventlog.forEach(event => {
            var label = {
                type: event.type
            };
            labelNodes.push(label);
            beadLinks.push({
                source: event,
                target: label,
                label: true
            })
        });

        simulation = d3.forceSimulation(d3.merge([eventlog, labelNodes]))
            // .force("charge", d3.forceManyBody().strength(-100))
            // .force("collide", d3.forceCollide(30))
            .force("x", d3.forceX(width * 2).strength(0.01))
            .force("y", d3.forceY(o => {
                return auditLine.y()(o) - stepHeight(o) * 10
            }).strength(1))
            .force("links", d3.forceLink(beadLinks).distance(10))
            .on("tick", tick);

        var g_nodes = focus.append("g").attr("class", "nodes").style("filter", "url(#dropshadow)");

        var links = focus.selectAll("path.bead").data(simulation.force("links").links());
        var auditPath = links.enter().filter(l => l.interbead).insert("path", ":first-child")
            .attr("class", "bead");
        var shadowPath = links.enter().filter(l => l.interbead).insert("path", ":first-child")
            .attr("class", "shadowbead").style("filter", "url(#dropshadow)").style("opacity", 0.3);
        var processheader = focus.selectAll("text").data(data.filter(d => d.values.length > 2)).enter().append("text").attr("class", "processheader").text(o => o.values[0].process).attr("y", height / 4 - margin.top);

        var labels = links.enter().filter(l => l.label).append("g")
            .style("filter", "url(#dropshadow)")
            .attr("class", "label").each(function() {
                d3.select(this)
                    .append("text")
                    .text(o => {
                        return o.source.target ? o.source.type + " (" + o.source.target + ")" : o.source.type;

                    });

                d3.select(this)
                    .append("path");

                var labelmargin = 4;

                d3.select(this).insert("rect", ":first-child")
                    .attr("x", function(d) {
                        var text = this.parentNode.childNodes[1].getBBox();
                        return text.x - labelmargin;
                    })
                    .attr("y", function(d) {
                        var text = this.parentNode.childNodes[1].getBBox();
                        return text.y;
                    })
                    .attr("width", function(d) {
                        var text = this.parentNode.childNodes[1].getBBox();
                        return d.width = text.width + 2 * labelmargin;
                    })
                    .attr("height", function(d) {
                        var text = this.parentNode.childNodes[1].getBBox();
                        return d.height = text.height;
                    });
                d3.select(this).insert("path", ":first-child");
            })

        var beads = g_nodes.selectAll("g.bead").data(eventlog, n => n.date.getTime() + n.pid);

        beads = beads.enter().append("g").attr("class", "bead").each(function(o) {
            d3.select(this).append("use").attr("xlink:href", o => "#" + o.device);
            d3.select(this).filter(single_event).insert("path", ":first-child").attr("class", "singleevent_line").attr("d", o => "M0,0L0,-" + auditLine.y()(0));

        }).merge(beads);


        function tick() {

            d3.selectAll(".processheader")
                .attr("x", o => {
                    var dateRange = d3.extent(o.values, o => o.date);
                    var coordRange = dateRange.map(d => {
                        return auditLine.x()({
                            date: d
                        });
                    });
                    return coordRange[0];
                })
                .style("font-size", o => {
                    var dateRange = d3.extent(o.values, o => o.date);
                    var coordRange = dateRange.map(d => {
                        return auditLine.x()({
                            date: d
                        });
                    });
                    var width = coordRange[1] - coordRange[0];
                    return width / 7;
                });

            d3.selectAll("path.points").attr("d", o => {
                var pt = o.location.split(",").map(o => +o);
                return geopath(geojson_pt(pt));
            });

            beads.attr("transform", o => {
                return "translate(" + o.fx + "," + o.fy + ")";
            });

            auditPath.attr("d", link => {
                if (geo) {
                    return swoosh(flying_arc(link));
                } else {
                    return auditLine([link.source, link.target]);
                }
            });

            shadowPath.attr("d", link => {
                if (geo) {
                    var source = link.source.location.split(",").map(o => +o);
                    var target = link.target.location.split(",").map(o => +o);

                    return geopath(geojson_line(source, target));
                } else {
                    return "";
                }
            });

            d3.selectAll("g.label")
                .attr("transform", l => "translate(" + l.target.x + "," + l.target.y + ")")
                .each(function(l) {
                    var delta = [l.source.x - l.target.x, l.source.y - l.target.y];

                    d3.select(this).select("path").attr("d", "M" + delta.join() + "L0,0L7,0");
                });
        }
        */

    var workkeys = descriptions.filter(o => o.type == "work").map(o => o.name);
    var studykeys = descriptions.filter(o => o.type == "study").map(o => o.name);

    var workdata = d3.stack().keys(workkeys).order(d3.stackOrderNone)(workstack);

    var studydata = d3.stack().keys(studykeys).order(d3.stackOrderNone)(studystack);

    var workcolor = d3.scaleSequential(d3.interpolateOranges).domain([0, 10]);
    var studycolor = d3.scaleSequential(d3.interpolateBlues).domain([5, -5]);


    focus.append("g")
        .attr("transform", "translate(0,-10)")
        .selectAll("path")
        .data(workdata)
        .enter()
        .each(function(o, i) {
            d3.select(this)
                .append("path")
                .attr("class", "stream workarea")
                .attr("fill", "url(#work_gradient_" + i + ")");
            d3.select(this)
                .append("defs")
                .append("linearGradient")
                .attr("id", "work_gradient_" + o.index)
                .attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", 1)
                .each(function(oo) {
                    d3.select(this).append("stop").attr("offset", "0%").attr("stop-color", workcolor(i));
                    d3.select(this).append("stop").attr("offset", "100%").attr("stop-color", workcolor(i - 2)).attr("stop-opacity", "0.5");
                })
        })

    focus.append("g")
        .attr("transform", "translate(0,10)")
        .selectAll("path")
        .data(studydata)
        .enter()
        .each(function(o, i) {
            d3.select(this)
                .append("path")
                .attr("class", "stream studyarea")
                .attr("fill", "url(#study_gradient_" + i + ")");
            d3.select(this)
                .append("defs")
                .append("linearGradient")
                .attr("id", "study_gradient_" + o.index)
                .attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", 1)
                .each(function(oo) {
                    d3.select(this).append("stop").attr("offset", "0%").attr("stop-color", studycolor(i - 2)).attr("stop-opacity", "0.5");
                    d3.select(this).append("stop").attr("offset", "100%").attr("stop-color", studycolor(i));
                })
        })

    // focus.selectAll(".stream")
    //     .on("mouseover", function(d, i) {
    //     	d3.select(this).style("fill", "white");

    //     })
    //     .on("mouseout", function(d, i) {
    //         svg.selectAll(".layer")
    //             .transition()
    //             .duration(250)
    //             .attr("opacity", "1");
    //         d3.select(this)
    //             .classed("hover", false)
    //             .attr("stroke-width", "0px"), indicator.style("visibility", "hidden");
    //     })


    //   ,,           ,,                  ,,
    // `7MM          *MM                `7MM
    //   MM           MM                  MM
    //   MM   ,6"Yb.  MM,dMMb.   .gP"Ya   MM  ,pP"Ybd
    //   MM  8)   MM  MM    `Mb ,M'   Yb  MM  8I   `"
    //   MM   ,pm9MM  MM     M8 8M""""""  MM  `YMMMa.
    //   MM  8M   MM  MM.   ,M9 YM.    ,  MM  L.   I8
    // .JMML.`Moo9^Yo.P^YbmdP'   `Mbmmd'.JMML.M9mmmP'


  	focus.selectAll("g.label")
  		.data(labels)
  		.enter()
		.append("g")
  		.attr("class", o => {
  			return "label " + (is_work(o.name) ? "worklabel" : "studylabel");
  		})
  		.append("text")
  		.attr("y", o => {
  			var sign = is_work(o.name) ? 1 : -1;
  			return y(sign * Math.sqrt(o.y)/1.2);
  		})
  		.text(o => o.name)
  		.each(rectify);

  	function rectify(d,i) {
            var labelmargin = 4;
            var parent = d3.select(this.parentNode);
            var box = this.getBBox();
            box.x += d3.select(this).attr("x");

            parent.insert("rect", ":first-child")
            	.attr("x", box.x-labelmargin)
            	.attr("y", box.y)
            	.attr("rx", 3)
            	.attr("ry", 3)
            	.attr("width", box.width+2*labelmargin)
            	.attr("height", box.height)
  	}

  	//                       ,,
  	//                       db
  	
  	//  ,6"Yb.  `7M'   `MF'`7MM  ,pP"Ybd
  	// 8)   MM    `VA ,V'    MM  8I   `"
  	//  ,pm9MM      XMX      MM  `YMMMa.
  	// 8M   MM    ,V' VA.    MM  L.   I8
  	// `Moo9^Yo..AM.   .MA..JMML.M9mmmP'
  	
  	

    focus.append("g")
        .attr("class", "axis axis--x focus")
        .attr("transform", "translate(0," + (y(0) - 14) + ")")
        .style("filter", "url(#dropshadow)")
        .call(xAxis);

    focus.append("g")
        .attr("class", "axis axis--y")
        .call(yAxis);

    context.append("g")
        .attr("class", "axis axis--x context")
        .attr("transform", "translate(0," + height2 + ")")
        .call(xAxis2);

    context.append("g")
        .attr("class", "brush")
        .call(brush)
        .call(brush.move, startRange);

    svg.append("rect")
        .attr("class", "zoom")
        .attr("width", width)
        .attr("height", height)
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        .call(zoom);



    function brushed() {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
        var s = d3.event.selection || x2.range();
        x.domain(s.map(x2.invert, x2));

        focus.select(".axis--x").call(xAxis);
        svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
            .scale(width / (s[1] - s[0]))
            .translate(-s[0], 0));

        focus.selectAll(".workarea").attr("d", workarea);
        focus.selectAll(".studyarea").attr("d", studyarea);
        focus.selectAll(".label").attr("transform", o => "translate("+ x(o.date) + ")");

        // events.forEach(node => {
        //     node.fx = x(node.date);
        //     node.fy = workArea.y()(node);
        // });

        // fix x-axis into bar:
        axis_callback();
        // simulation.alpha(1);
        // simulation.restart();



    }

    function zoomed() {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
        var t = d3.event.transform;
        x.domain(t.rescaleX(x2).domain());

        focus.select(".axis--x").call(xAxis);
        context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
        focus.selectAll(".work").attr("d", workarea);
        focus.selectAll(".study").attr("d", studyarea);
        focus.selectAll(".label").attr("transform", o => "translate("+ x(o.date) + ")");

        // fix x-axis into bar:
        axis_callback();
        // simulation.alpha(1);
        // simulation.restart();
    }

}
</script>
